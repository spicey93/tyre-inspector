// scripts/seedInspections.mjs
import mongoose from "mongoose";
import Inspection from "../models/inspection.model.js";

// ---- Config ----
const MONGODB_URI =
  process.env.MONGODB_URI || "mongodb://127.0.0.1:27017/tyre-inspector";

// CLI: node scripts/seedInspections.mjs --count=25 --purge
const argv = Object.fromEntries(
  process.argv.slice(2).map((a) => {
    const [k, v] = a.replace(/^--/, "").split("=");
    return [k, v ?? true];
  })
);

const COUNT = Number(argv.count || 10);
const PURGE = Boolean(argv.purge);

// ---- Helpers ----
const brands = [
  "MICHELIN CROSSCLIMATE",
  "Pirelli Cinturato",
  "Goodyear Eagle F1",
  "Bridgestone Potenza",
  "Continental PremiumContact",
  "Hankook Ventus",
  "Dunlop Sport"
];

const sizes = [
  "205/55 R16 91V",
  "225/45 R17 94W",
  "195/65 R15 91H",
  "215/55 R18 99V",
  "235/40 R18 95Y",
  "245/45 R19 102W",
  "265/35 R19 98Y",
];

const statuses = ["Good", "Warning", "Bad"];

// random int inclusive
const ri = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
// random float with 1 dp
const rf1 = (min, max) => Math.round((Math.random() * (max - min) + min) * 10) / 10;

function randomDOT() {
  const week = ri(1, 53).toString().padStart(2, "0");
  const yy = ri(21, 25).toString().padStart(2, "0"); // years 2021â€“2025
  return `${week}${yy}`;
}

function maybe(probTrue = 0.5) {
  return Math.random() < probTrue;
}

function makeTyre() {
  const inner = rf1(5, 8);
  const middle = Math.max(0, inner - rf1(0, 1));
  const outer = Math.max(0, middle - rf1(0, 1));
  return {
    size: sizes[ri(0, sizes.length - 1)], // NEW
    treadDepth: { inner, middle, outer },
    psi: rf1(28, 36),
    brand: brands[ri(0, brands.length - 1)],
    dot: randomDOT(),
    notes: maybe(0.3) ? "Minor wear on edges" : "",
    status: statuses[ri(0, statuses.length - 1)],
  };
}


function randomVRM() {
  // Simple UK-ish plate mock: AB12 CDE
  const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const pick = (n) => Array.from({ length: n }, () => letters[ri(0, 25)]).join("");
  return `${pick(2)}${ri(10, 99)} ${pick(3)}`;
}

function makeInspection() {
  return {
    vrm: randomVRM(),
    mileage: `${ri(10000, 120000)}`,
    notes: maybe(0.4) ? "Customer reported vibration at 60mph." : "",
    tyres: {
      nearside: { front: makeTyre(), rear: makeTyre() },
      offside:  { front: makeTyre(), rear: makeTyre() },
      // REMOVED: spare
    },
  };
}


// ---- Main ----
async function main() {
  console.log(`Connecting to ${MONGODB_URI} ...`);
  await mongoose.connect(MONGODB_URI);

  if (PURGE) {
    console.log("Purging existing inspections...");
    await Inspection.deleteMany({});
  }

  // Ensure indexes (unique index on code) are ready
  await Inspection.syncIndexes();

  const payload = Array.from({ length: COUNT }, makeInspection);

  console.log(`Inserting ${COUNT} inspections...`);
  const docs = await Inspection.insertMany(payload, { ordered: false });

  // Print a tiny table of created docs
  console.log("\nCreated inspections:");
  for (const d of docs) {
    // `code` is generated by your pre-validate hook
    console.log(`- ${d.code}  (id: ${d._id})  VRM: ${d.vrm}`);
  }

  console.log("\nTry opening one in the browser, e.g.:");
  if (docs[0]?.code) {
    console.log(`  /inspections?code=${docs[0].code}`);
  }

  await mongoose.disconnect();
  console.log("Done.");
}

main().catch(async (err) => {
  console.error("Seed failed:", err);
  try { await mongoose.disconnect(); } catch {}
  process.exit(1);
});
