// scripts/seedInspections.mjs
import mongoose from "mongoose";
import Inspection from "../models/inspection.model.js";

// ---- Config ----
const MONGODB_URI =
  process.env.MONGODB_URI || "mongodb://127.0.0.1:27017/tyre-inspector";

// CLI: node scripts/seedInspections.mjs --count=25 --purge
const argv = Object.fromEntries(
  process.argv.slice(2).map((a) => {
    const [k, v] = a.replace(/^--/, "").split("=");
    return [k, v ?? true];
  })
);

const COUNT = Number(argv.count || 10);
const PURGE = Boolean(argv.purge);

// ---- Helpers ----
const brands = [
  "MICHELIN CROSSCLIMATE",
  "Pirelli Cinturato",
  "Goodyear Eagle F1",
  "Bridgestone Potenza",
  "Continental PremiumContact",
  "Hankook Ventus",
  "Dunlop Sport"
];

const statuses = ["Good", "Warning", "Bad"];

// random int inclusive
const ri = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
// random float with 1 dp
const rf1 = (min, max) => Math.round((Math.random() * (max - min) + min) * 10) / 10;

function randomDOT() {
  const week = ri(1, 53).toString().padStart(2, "0");
  const yy = ri(21, 25).toString().padStart(2, "0"); // years 2021â€“2025
  return `${week}${yy}`;
}

function maybe(probTrue = 0.5) {
  return Math.random() < probTrue;
}

function makeTyre({ allowEmpty = true } = {}) {
  // 35% chance to leave a tyre completely empty (to test your "no data" UI)
  if (allowEmpty && maybe(0.35)) return undefined;

  const tdInner = rf1(5, 8);
  const tdMiddle = Math.max(0, tdInner - rf1(0, 1));
  const tdOuter = Math.max(0, tdMiddle - rf1(0, 1));

  return {
    treadDepth: {
      inner: tdInner,
      middle: tdMiddle,
      outer: tdOuter,
    },
    psi: rf1(28, 36),
    brand: brands[ri(0, brands.length - 1)],
    dot: randomDOT(),
    notes: maybe(0.3) ? "Minor wear on edges" : "",
    status: statuses[ri(0, statuses.length - 1)],
  };
}

function randomVRM() {
  // Simple UK-ish plate mock: AB12 CDE
  const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const pick = (n) => Array.from({ length: n }, () => letters[ri(0, 25)]).join("");
  return `${pick(2)}${ri(10, 99)} ${pick(3)}`;
}

function makeInspection() {
  return {
    vrm: randomVRM(),
    mileage: `${ri(10_000, 120_000)}`,
    notes: maybe(0.4) ? "Customer reported vibration at 60mph." : "",
    tyres: {
      nearside: {
        front: makeTyre(),
        rear: makeTyre(),
      },
      offside: {
        front: makeTyre(),
        rear: makeTyre(),
      },
      spare: makeTyre({ allowEmpty: true }),
    },
  };
}

// ---- Main ----
async function main() {
  console.log(`Connecting to ${MONGODB_URI} ...`);
  await mongoose.connect(MONGODB_URI);

  if (PURGE) {
    console.log("Purging existing inspections...");
    await Inspection.deleteMany({});
  }

  // Ensure indexes (unique index on code) are ready
  await Inspection.syncIndexes();

  const payload = Array.from({ length: COUNT }, makeInspection);

  console.log(`Inserting ${COUNT} inspections...`);
  const docs = await Inspection.insertMany(payload, { ordered: false });

  // Print a tiny table of created docs
  console.log("\nCreated inspections:");
  for (const d of docs) {
    // `code` is generated by your pre-validate hook
    console.log(`- ${d.code}  (id: ${d._id})  VRM: ${d.vrm}`);
  }

  console.log("\nTry opening one in the browser, e.g.:");
  if (docs[0]?.code) {
    console.log(`  /inspections?code=${docs[0].code}`);
  }

  await mongoose.disconnect();
  console.log("Done.");
}

main().catch(async (err) => {
  console.error("Seed failed:", err);
  try { await mongoose.disconnect(); } catch {}
  process.exit(1);
});
